[[[Part 1]]] The disaggregate function's goal is to take an input array and break into 2 smaller arrays containing elements that are smaller than and greater than the average of the given array. To ensure the original data passed into each recursive call does not get overwritten, the function allocated 28 bytes of memory to store the input array[$s0], depth[$s1], pointer to the 400 byte buffer [$s2], length of the array[$s3], and return address [$ra]. The function then prints out the input array using loop, checks the base case to see if the depth is 0 and lengths of the input array is 1, proceeds to split the array further (storing results in buffer -first 40/80 bytes for the small array and last 40/80 bytes for the big array) if the base case is false and terminate the function calls if the base case is true. With each recursive call 80 additional bytes are allocated to store the small and big arrays. With each recursive call, the values of registers $s0-s5 & $ra are reloaded and modified so that each time the new input array passed in is the according small array we have stored in our buffer.

[[[Part 2]]] A change in array values should not change the space allocated on the stack since a change in value would not affect any of the values stored in $s0-5 or $ra or the number of recursive calls made. However, a decrease in array length could cause a decrease in the number of recursive calls needed and thus decrease the depth size as well, decreasing the number of times 28 bytes of stack space is allocated. Additionally, an increase in the array length could cause an increase in the depth size as well, increasing the number of times 28 bytes of stack space is allocated. 